<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VRM Green Screen Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.2/lib/three-vrm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.rawgit.com/yeemachine/kalidokit/master/dist/kalidokit.itools.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #00ff00; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 10px; width: calc(100% - 50px); color: white; }
        #video { position: absolute; bottom: 10px; right: 10px; width: 80px; height: 60px; border: 1px solid white; z-index: 10; transform: scaleX(-1); border-radius: 5px; background: #000; }
        input, button { font-size: 16px; margin: 8px 0; padding: 12px; width: 100%; border-radius: 5px; box-sizing: border-box; }
        button { background: #007bff; color: white; border: none; font-weight: bold; }
        #error-log { color: #ff4444; font-size: 12px; margin-top: 10px; white-space: pre-wrap; }
        #status { color: #00ff00; font-size: 14px; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        <b>1. VRMファイルを選択</b>
        <input type="file" id="fileInput" accept=".vrm">
        <div id="status">VRM未選択</div>
        <br>
        <b>2. カメラ起動</b>
        <button id="startBtn">カメラを開始してUIを隠す</button>
        <div id="error-log"></div>
    </div>

    <video id="video" playsinline webkit-playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <script>
        const log = (msg) => { document.getElementById('error-log').textContent += msg + "\n"; console.log(msg); };
        
        let currentVrm = null;
        const videoElement = document.getElementById('video');
        const statusElement = document.getElementById('status');

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00ff00);
        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 20);
        camera.position.set(0, 1.4, 1.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.0);
        light.position.set(1, 1, 1).normalize();
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.7));

        // --- VRM Load ---
        const loader = new THREE.GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            statusElement.textContent = "読み込み中...";
            const url = URL.createObjectURL(file);
            loader.load(url, (gltf) => {
                THREE.VRM.from(gltf).then((vrm) => {
                    if (currentVrm) scene.remove(currentVrm.scene);
                    currentVrm = vrm;
                    scene.add(vrm.scene);
                    vrm.scene.rotation.y = Math.PI;
                    statusElement.textContent = "VRM準備完了！";
                    log("VRM Load Success");
                }).catch(err => log("VRM Error: " + err));
            }, undefined, (err) => log("Loader Error: " + err));
        });

        // --- Face Mesh ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5 });
        faceMesh.onResults((results) => {
            if (!currentVrm || !results.multiFaceLandmarks || !results.multiFaceLandmarks[0]) return;
            const rig = Kalidokit.Face.solve(results.multiFaceLandmarks[0], { runtime: 'mediapipe', video: videoElement });
            const head = currentVrm.humanoid.getRawBoneNode('head');
            if (head) {
                head.rotation.y = rig.head.y;
                head.rotation.x = rig.head.x;
            }
            const s = rig.mouth.shape;
            currentVrm.expressionManager.setValue('aa', s.A);
            currentVrm.expressionManager.setValue('ih', s.I);
            currentVrm.expressionManager.setValue('ou', s.U);
            currentVrm.expressionManager.setValue('ee', s.E);
            currentVrm.expressionManager.setValue('oh', s.O);
            currentVrm.expressionManager.setValue('blink', 1 - rig.eye.l);
        });

        // --- Start ---
        document.getElementById('startBtn').addEventListener('click', async () => {
            log("Camera starting...");
            try {
                const cameraTracker = new Camera(videoElement, {
                    onFrame: async () => { await faceMesh.send({image: videoElement}); },
                    width: 640, height: 480
                });
                await cameraTracker.start();
                log("Camera active.");
                document.getElementById('ui').style.display = "none";
            } catch (err) {
                log("Camera Failed: " + err);
                alert("カメラが起動できません。設定で許可されているか、他のアプリでカメラを使っていないか確認してください。");
            }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if (currentVrm) currentVrm.update(clock.getDelta());
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.7));

        // --- VRM読み込み ---
        const loader = new THREE.GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            loader.load(url, (gltf) => {
                THREE.VRM.from(gltf).then((vrm) => {
                    if (currentVrm) scene.remove(currentVrm.scene);
                    currentVrm = vrm;
                    scene.add(vrm.scene);
                    vrm.scene.rotation.y = Math.PI;
                    statusElement.textContent = "準備完了！";
                });
            });
        });

        // --- Face Mesh ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5 });
        faceMesh.onResults((results) => {
            if (!currentVrm || !results.multiFaceLandmarks[0]) return;
            const rig = Kalidokit.Face.solve(results.multiFaceLandmarks[0], { runtime: 'mediapipe', video: videoElement });
            
            const head = currentVrm.humanoid.getRawBoneNode('head');
            if (head) {
                head.rotation.y = rig.head.y;
                head.rotation.x = rig.head.x;
                head.rotation.z = rig.head.z;
            }
            const s = rig.mouth.shape;
            currentVrm.expressionManager.setValue('aa', s.A);
            currentVrm.expressionManager.setValue('ih', s.I);
            currentVrm.expressionManager.setValue('ou', s.U);
            currentVrm.expressionManager.setValue('ee', s.E);
            currentVrm.expressionManager.setValue('oh', s.O);
            currentVrm.expressionManager.setValue('blink', 1 - rig.eye.l);
        });

        // --- ボタンクリックで開始 ＆ UIを隠す ---
        document.getElementById('startBtn').addEventListener('click', async () => {
            try {
                const cameraTracker = new Camera(videoElement, {
                    onFrame: async () => { await faceMesh.send({image: videoElement}); },
                    width: 640, height: 480
                });
                await cameraTracker.start();
                
                // UIパネルを隠す
                uiElement.style.opacity = "0";
                setTimeout(() => { uiElement.style.display = "none"; }, 500);
                
            } catch (err) {
                alert("エラー: " + err);
            }
        });

        // 隠れたUIを再表示する機能（画面のどこかをタップ）
        window.addEventListener('dblclick', () => {
            uiElement.style.display = "block";
            uiElement.style.opacity = "1";
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if (currentVrm) currentVrm.update(clock.getDelta());
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

